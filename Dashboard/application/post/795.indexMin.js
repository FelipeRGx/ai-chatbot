"use strict";exports.id=795,exports.ids=[795],exports.modules={9795:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  fromSSO: () => (/* reexport */ fromSSO)\n});\n\n// UNUSED EXPORTS: isSsoProfile, validateSsoProfile\n\n// EXTERNAL MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js\nvar CredentialsProviderError = __webpack_require__(7124);\n// EXTERNAL MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@smithy/shared-ini-file-loader/dist-es/index.js + 14 modules\nvar dist_es = __webpack_require__(997);\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js\nconst isSsoProfile = (arg) => arg &&\n    (typeof arg.sso_start_url === "string" ||\n        typeof arg.sso_account_id === "string" ||\n        typeof arg.sso_session === "string" ||\n        typeof arg.sso_region === "string" ||\n        typeof arg.sso_role_name === "string");\n\n// EXTERNAL MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/ProviderError.js\nvar ProviderError = __webpack_require__(3282);\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@smithy/property-provider/dist-es/TokenProviderError.js\n\nclass TokenProviderError extends ProviderError/* ProviderError */.k {\n    constructor(message, options = true) {\n        super(message, options);\n        this.name = "TokenProviderError";\n        Object.setPrototypeOf(this, TokenProviderError.prototype);\n    }\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/token-providers/dist-es/constants.js\nconst EXPIRE_WINDOW_MS = 5 * 60 * 1000;\nconst REFRESH_MESSAGE = `To refresh this SSO session run \'aws sso login\' with the corresponding profile.`;\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js\nconst ssoOidcClientsHash = {};\nconst getSsoOidcClient = async (ssoRegion) => {\n    const { SSOOIDCClient } = await __webpack_require__.e(/* import() */ 516).then(__webpack_require__.bind(__webpack_require__, 4516));\n    if (ssoOidcClientsHash[ssoRegion]) {\n        return ssoOidcClientsHash[ssoRegion];\n    }\n    const ssoOidcClient = new SSOOIDCClient({ region: ssoRegion });\n    ssoOidcClientsHash[ssoRegion] = ssoOidcClient;\n    return ssoOidcClient;\n};\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js\n\nconst getNewSsoOidcToken = async (ssoToken, ssoRegion) => {\n    const { CreateTokenCommand } = await __webpack_require__.e(/* import() */ 516).then(__webpack_require__.bind(__webpack_require__, 4516));\n    const ssoOidcClient = await getSsoOidcClient(ssoRegion);\n    return ssoOidcClient.send(new CreateTokenCommand({\n        clientId: ssoToken.clientId,\n        clientSecret: ssoToken.clientSecret,\n        refreshToken: ssoToken.refreshToken,\n        grantType: "refresh_token",\n    }));\n};\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js\n\n\nconst validateTokenExpiry = (token) => {\n    if (token.expiration && token.expiration.getTime() < Date.now()) {\n        throw new TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);\n    }\n};\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js\n\n\nconst validateTokenKey = (key, value, forRefresh = false) => {\n    if (typeof value === "undefined") {\n        throw new TokenProviderError(`Value not present for \'${key}\' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);\n    }\n};\n\n// EXTERNAL MODULE: external "fs"\nvar external_fs_ = __webpack_require__(7147);\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js\n\n\nconst { writeFile } = external_fs_.promises;\nconst writeSSOTokenToFile = (id, ssoToken) => {\n    const tokenFilepath = (0,dist_es/* getSSOTokenFilepath */.Py)(id);\n    const tokenString = JSON.stringify(ssoToken, null, 2);\n    return writeFile(tokenFilepath, tokenString);\n};\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/token-providers/dist-es/fromSso.js\n\n\n\n\n\n\n\nconst lastRefreshAttemptTime = new Date(0);\nconst fromSso = (init = {}) => async () => {\n    init.logger?.debug("@aws-sdk/token-providers - fromSso");\n    const profiles = await (0,dist_es/* parseKnownFiles */.MX)(init);\n    const profileName = (0,dist_es/* getProfileName */.Jl)(init);\n    const profile = profiles[profileName];\n    if (!profile) {\n        throw new TokenProviderError(`Profile \'${profileName}\' could not be found in shared credentials file.`, false);\n    }\n    else if (!profile["sso_session"]) {\n        throw new TokenProviderError(`Profile \'${profileName}\' is missing required property \'sso_session\'.`);\n    }\n    const ssoSessionName = profile["sso_session"];\n    const ssoSessions = await (0,dist_es/* loadSsoSessionData */.G)(init);\n    const ssoSession = ssoSessions[ssoSessionName];\n    if (!ssoSession) {\n        throw new TokenProviderError(`Sso session \'${ssoSessionName}\' could not be found in shared credentials file.`, false);\n    }\n    for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {\n        if (!ssoSession[ssoSessionRequiredKey]) {\n            throw new TokenProviderError(`Sso session \'${ssoSessionName}\' is missing required property \'${ssoSessionRequiredKey}\'.`, false);\n        }\n    }\n    const ssoStartUrl = ssoSession["sso_start_url"];\n    const ssoRegion = ssoSession["sso_region"];\n    let ssoToken;\n    try {\n        ssoToken = await (0,dist_es/* getSSOTokenFromFile */.gH)(ssoSessionName);\n    }\n    catch (e) {\n        throw new TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);\n    }\n    validateTokenKey("accessToken", ssoToken.accessToken);\n    validateTokenKey("expiresAt", ssoToken.expiresAt);\n    const { accessToken, expiresAt } = ssoToken;\n    const existingToken = { token: accessToken, expiration: new Date(expiresAt) };\n    if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {\n        return existingToken;\n    }\n    if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {\n        validateTokenExpiry(existingToken);\n        return existingToken;\n    }\n    validateTokenKey("clientId", ssoToken.clientId, true);\n    validateTokenKey("clientSecret", ssoToken.clientSecret, true);\n    validateTokenKey("refreshToken", ssoToken.refreshToken, true);\n    try {\n        lastRefreshAttemptTime.setTime(Date.now());\n        const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion);\n        validateTokenKey("accessToken", newSsoOidcToken.accessToken);\n        validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);\n        const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);\n        try {\n            await writeSSOTokenToFile(ssoSessionName, {\n                ...ssoToken,\n                accessToken: newSsoOidcToken.accessToken,\n                expiresAt: newTokenExpiration.toISOString(),\n                refreshToken: newSsoOidcToken.refreshToken,\n            });\n        }\n        catch (error) {\n        }\n        return {\n            token: newSsoOidcToken.accessToken,\n            expiration: newTokenExpiration,\n        };\n    }\n    catch (error) {\n        validateTokenExpiry(existingToken);\n        return existingToken;\n    }\n};\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js\n\n\n\nconst SHOULD_FAIL_CREDENTIAL_CHAIN = false;\nconst resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, clientConfig, profile, logger, }) => {\n    let token;\n    const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;\n    if (ssoSession) {\n        try {\n            const _token = await fromSso({ profile })();\n            token = {\n                accessToken: _token.token,\n                expiresAt: new Date(_token.expiration).toISOString(),\n            };\n        }\n        catch (e) {\n            throw new CredentialsProviderError/* CredentialsProviderError */.m(e.message, {\n                tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,\n                logger,\n            });\n        }\n    }\n    else {\n        try {\n            token = await (0,dist_es/* getSSOTokenFromFile */.gH)(ssoStartUrl);\n        }\n        catch (e) {\n            throw new CredentialsProviderError/* CredentialsProviderError */.m(`The SSO session associated with this profile is invalid. ${refreshMessage}`, {\n                tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,\n                logger,\n            });\n        }\n    }\n    if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {\n        throw new CredentialsProviderError/* CredentialsProviderError */.m(`The SSO session associated with this profile has expired. ${refreshMessage}`, {\n            tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,\n            logger,\n        });\n    }\n    const { accessToken } = token;\n    const { SSOClient, GetRoleCredentialsCommand } = await __webpack_require__.e(/* import() */ 177).then(__webpack_require__.bind(__webpack_require__, 6177));\n    const sso = ssoClient ||\n        new SSOClient(Object.assign({}, clientConfig ?? {}, {\n            region: clientConfig?.region ?? ssoRegion,\n        }));\n    let ssoResp;\n    try {\n        ssoResp = await sso.send(new GetRoleCredentialsCommand({\n            accountId: ssoAccountId,\n            roleName: ssoRoleName,\n            accessToken,\n        }));\n    }\n    catch (e) {\n        throw new CredentialsProviderError/* CredentialsProviderError */.m(e, {\n            tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,\n            logger,\n        });\n    }\n    const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration, credentialScope, accountId } = {}, } = ssoResp;\n    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {\n        throw new CredentialsProviderError/* CredentialsProviderError */.m("SSO returns an invalid temporary credential.", {\n            tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,\n            logger,\n        });\n    }\n    return {\n        accessKeyId,\n        secretAccessKey,\n        sessionToken,\n        expiration: new Date(expiration),\n        ...(credentialScope && { credentialScope }),\n        ...(accountId && { accountId }),\n    };\n};\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js\n\nconst validateSsoProfile = (profile, logger) => {\n    const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;\n    if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {\n        throw new CredentialsProviderError/* CredentialsProviderError */.m(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` +\n            `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}\\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, { tryNextLink: false, logger });\n    }\n    return profile;\n};\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js\n\n\n\n\n\nconst fromSSO = (init = {}) => async () => {\n    init.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");\n    const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;\n    const { ssoClient } = init;\n    const profileName = (0,dist_es/* getProfileName */.Jl)(init);\n    if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {\n        const profiles = await (0,dist_es/* parseKnownFiles */.MX)(init);\n        const profile = profiles[profileName];\n        if (!profile) {\n            throw new CredentialsProviderError/* CredentialsProviderError */.m(`Profile ${profileName} was not found.`, { logger: init.logger });\n        }\n        if (!isSsoProfile(profile)) {\n            throw new CredentialsProviderError/* CredentialsProviderError */.m(`Profile ${profileName} is not configured with SSO credentials.`, {\n                logger: init.logger,\n            });\n        }\n        if (profile?.sso_session) {\n            const ssoSessions = await (0,dist_es/* loadSsoSessionData */.G)(init);\n            const session = ssoSessions[profile.sso_session];\n            const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;\n            if (ssoRegion && ssoRegion !== session.sso_region) {\n                throw new CredentialsProviderError/* CredentialsProviderError */.m(`Conflicting SSO region` + conflictMsg, {\n                    tryNextLink: false,\n                    logger: init.logger,\n                });\n            }\n            if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {\n                throw new CredentialsProviderError/* CredentialsProviderError */.m(`Conflicting SSO start_url` + conflictMsg, {\n                    tryNextLink: false,\n                    logger: init.logger,\n                });\n            }\n            profile.sso_region = session.sso_region;\n            profile.sso_start_url = session.sso_start_url;\n        }\n        const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile, init.logger);\n        return resolveSSOCredentials({\n            ssoStartUrl: sso_start_url,\n            ssoSession: sso_session,\n            ssoAccountId: sso_account_id,\n            ssoRegion: sso_region,\n            ssoRoleName: sso_role_name,\n            ssoClient: ssoClient,\n            clientConfig: init.clientConfig,\n            profile: profileName,\n        });\n    }\n    else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {\n        throw new CredentialsProviderError/* CredentialsProviderError */.m("Incomplete configuration. The fromSSO() argument hash must include " +\n            \'"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"\', { tryNextLink: false, logger: init.logger });\n    }\n    else {\n        return resolveSSOCredentials({\n            ssoStartUrl,\n            ssoSession,\n            ssoAccountId,\n            ssoRegion,\n            ssoRoleName,\n            ssoClient,\n            clientConfig: init.clientConfig,\n            profile: profileName,\n        });\n    }\n};\n\n;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-sts/node_modules/@aws-sdk/credential-provider-sso/dist-es/index.js\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTc5NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xnRDtBQUN6QyxpQ0FBaUMsa0NBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQTztBQUNBOzs7QUNEUDtBQUNPO0FBQ1AsWUFBWSxnQkFBZ0IsUUFBUSxtR0FBa0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0E7OztBQ1RzRDtBQUMvQztBQUNQLFlBQVkscUJBQXFCLFFBQVEsbUdBQWtDO0FBQzNFLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FDVitEO0FBQ2pCO0FBQ3ZDO0FBQ1A7QUFDQSxrQkFBa0Isa0JBQWtCLHNCQUFzQixlQUFlLENBQUM7QUFDMUU7QUFDQTs7O0FDTitEO0FBQ2pCO0FBQ3ZDO0FBQ1A7QUFDQSxrQkFBa0Isa0JBQWtCLDJCQUEyQixJQUFJLGdCQUFnQixxQ0FBcUMsSUFBSSxlQUFlLENBQUM7QUFDNUk7QUFDQTs7Ozs7QUNOcUU7QUFDekI7QUFDNUMsUUFBUSxZQUFZLEVBQUUscUJBQVU7QUFDekI7QUFDUCwwQkFBMEIsdUNBQW1CO0FBQzdDO0FBQ0E7QUFDQTs7O0FDUCtEO0FBQzREO0FBQzNEO0FBQ047QUFDRTtBQUNOO0FBQ007QUFDNUQ7QUFDTywwQkFBMEI7QUFDakM7QUFDQSwyQkFBMkIsbUNBQWU7QUFDMUMsd0JBQXdCLGtDQUFjO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCLGFBQWEsWUFBWTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQixhQUFhLFlBQVk7QUFDN0Q7QUFDQTtBQUNBLDhCQUE4QixxQ0FBa0I7QUFDaEQ7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsaUJBQWlCLGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQixpQkFBaUIsZUFBZSxrQ0FBa0Msc0JBQXNCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1Q0FBbUI7QUFDNUM7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0Isa0RBQWtELGFBQWEsK0JBQStCLGVBQWUsQ0FBQztBQUNsSjtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksZ0JBQWdCO0FBQ3BCLFlBQVkseUJBQXlCO0FBQ3JDLDRCQUE0QjtBQUM1QiwwREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RCxRQUFRLGdCQUFnQjtBQUN4QixRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7OztBQzlFMEU7QUFDTDtBQUNBO0FBQ3JFO0FBQ08sdUNBQXVDLDBHQUEwRztBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFtQixHQUFHLFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUF3QjtBQUM5QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUFtQjtBQUM3QztBQUNBO0FBQ0Esc0JBQXNCLHdEQUF3Qiw2REFBNkQsZUFBZTtBQUMxSDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3REFBd0IsOERBQThELGVBQWU7QUFDdkg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLHVDQUF1QyxRQUFRLG1HQUFtQjtBQUM5RTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQXdCO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxZQUFZLG1CQUFtQixxRkFBcUYsSUFBSSxJQUFJO0FBQzVIO0FBQ0Esa0JBQWtCLHdEQUF3QjtBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTs7O0FDMUVxRTtBQUM5RDtBQUNQLFlBQVksMkRBQTJEO0FBQ3ZFO0FBQ0Esa0JBQWtCLHdEQUF3QjtBQUMxQyxtRUFBbUUsZ0NBQWdDLHlGQUF5Riw0QkFBNEI7QUFDeE47QUFDQTtBQUNBOzs7QUNScUU7QUFDZ0M7QUFDdkQ7QUFDa0I7QUFDTjtBQUNuRCwwQkFBMEI7QUFDakM7QUFDQSxZQUFZLGdFQUFnRTtBQUM1RSxZQUFZLFlBQVk7QUFDeEIsd0JBQXdCLGtDQUFjO0FBQ3RDO0FBQ0EsK0JBQStCLG1DQUFlO0FBQzlDO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQXdCLFlBQVksYUFBYSxtQkFBbUIscUJBQXFCO0FBQy9HO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLHNCQUFzQix3REFBd0IsWUFBWSxhQUFhO0FBQ3ZFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQ0FBc0MscUNBQWtCO0FBQ3hEO0FBQ0EsOERBQThELGFBQWEsa0JBQWtCLG9CQUFvQjtBQUNqSDtBQUNBLDBCQUEwQix3REFBd0I7QUFDbEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMEJBQTBCLHdEQUF3QjtBQUNsRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdFQUF3RSxFQUFFLGtCQUFrQjtBQUM1RyxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQXdCO0FBQzFDLDJFQUEyRSx5Q0FBeUM7QUFDcEg7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7O0FDcEUwQjtBQUNLO0FBQ1A7QUFDYSIsInNvdXJjZXMiOlsid2VicGFjazovL2luZGV4Ly4uLy4uL25vZGVfbW9kdWxlcy9AYXdzLXNkay9jbGllbnQtc3RzL25vZGVfbW9kdWxlcy9AYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVyLXNzby9kaXN0LWVzL2lzU3NvUHJvZmlsZS5qcz9iNTU4Iiwid2VicGFjazovL2luZGV4Ly4uLy4uL25vZGVfbW9kdWxlcy9AYXdzLXNkay9jbGllbnQtc3RzL25vZGVfbW9kdWxlcy9Ac21pdGh5L3Byb3BlcnR5LXByb3ZpZGVyL2Rpc3QtZXMvVG9rZW5Qcm92aWRlckVycm9yLmpzPzJhNjAiLCJ3ZWJwYWNrOi8vaW5kZXgvLi4vLi4vbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL2NsaWVudC1zdHMvbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL3Rva2VuLXByb3ZpZGVycy9kaXN0LWVzL2NvbnN0YW50cy5qcz82NDg5Iiwid2VicGFjazovL2luZGV4Ly4uLy4uL25vZGVfbW9kdWxlcy9AYXdzLXNkay9jbGllbnQtc3RzL25vZGVfbW9kdWxlcy9AYXdzLXNkay90b2tlbi1wcm92aWRlcnMvZGlzdC1lcy9nZXRTc29PaWRjQ2xpZW50LmpzP2FkZGQiLCJ3ZWJwYWNrOi8vaW5kZXgvLi4vLi4vbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL2NsaWVudC1zdHMvbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL3Rva2VuLXByb3ZpZGVycy9kaXN0LWVzL2dldE5ld1Nzb09pZGNUb2tlbi5qcz9mYTNlIiwid2VicGFjazovL2luZGV4Ly4uLy4uL25vZGVfbW9kdWxlcy9AYXdzLXNkay9jbGllbnQtc3RzL25vZGVfbW9kdWxlcy9AYXdzLXNkay90b2tlbi1wcm92aWRlcnMvZGlzdC1lcy92YWxpZGF0ZVRva2VuRXhwaXJ5LmpzPzgxODQiLCJ3ZWJwYWNrOi8vaW5kZXgvLi4vLi4vbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL2NsaWVudC1zdHMvbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL3Rva2VuLXByb3ZpZGVycy9kaXN0LWVzL3ZhbGlkYXRlVG9rZW5LZXkuanM/YjM4MiIsIndlYnBhY2s6Ly9pbmRleC8uLi8uLi9ub2RlX21vZHVsZXMvQGF3cy1zZGsvY2xpZW50LXN0cy9ub2RlX21vZHVsZXMvQGF3cy1zZGsvdG9rZW4tcHJvdmlkZXJzL2Rpc3QtZXMvd3JpdGVTU09Ub2tlblRvRmlsZS5qcz82NWFlIiwid2VicGFjazovL2luZGV4Ly4uLy4uL25vZGVfbW9kdWxlcy9AYXdzLXNkay9jbGllbnQtc3RzL25vZGVfbW9kdWxlcy9AYXdzLXNkay90b2tlbi1wcm92aWRlcnMvZGlzdC1lcy9mcm9tU3NvLmpzPzQwNzgiLCJ3ZWJwYWNrOi8vaW5kZXgvLi4vLi4vbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL2NsaWVudC1zdHMvbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL2NyZWRlbnRpYWwtcHJvdmlkZXItc3NvL2Rpc3QtZXMvcmVzb2x2ZVNTT0NyZWRlbnRpYWxzLmpzP2Q3MDMiLCJ3ZWJwYWNrOi8vaW5kZXgvLi4vLi4vbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL2NsaWVudC1zdHMvbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL2NyZWRlbnRpYWwtcHJvdmlkZXItc3NvL2Rpc3QtZXMvdmFsaWRhdGVTc29Qcm9maWxlLmpzPzNjODkiLCJ3ZWJwYWNrOi8vaW5kZXgvLi4vLi4vbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL2NsaWVudC1zdHMvbm9kZV9tb2R1bGVzL0Bhd3Mtc2RrL2NyZWRlbnRpYWwtcHJvdmlkZXItc3NvL2Rpc3QtZXMvZnJvbVNTTy5qcz9jNzY5Iiwid2VicGFjazovL2luZGV4Ly4uLy4uL25vZGVfbW9kdWxlcy9AYXdzLXNkay9jbGllbnQtc3RzL25vZGVfbW9kdWxlcy9AYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVyLXNzby9kaXN0LWVzL2luZGV4LmpzPzFkYWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGlzU3NvUHJvZmlsZSA9IChhcmcpID0+IGFyZyAmJlxuICAgICh0eXBlb2YgYXJnLnNzb19zdGFydF91cmwgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgdHlwZW9mIGFyZy5zc29fYWNjb3VudF9pZCA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICB0eXBlb2YgYXJnLnNzb19zZXNzaW9uID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgIHR5cGVvZiBhcmcuc3NvX3JlZ2lvbiA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICB0eXBlb2YgYXJnLnNzb19yb2xlX25hbWUgPT09IFwic3RyaW5nXCIpO1xuIiwiaW1wb3J0IHsgUHJvdmlkZXJFcnJvciB9IGZyb20gXCIuL1Byb3ZpZGVyRXJyb3JcIjtcbmV4cG9ydCBjbGFzcyBUb2tlblByb3ZpZGVyRXJyb3IgZXh0ZW5kcyBQcm92aWRlckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJUb2tlblByb3ZpZGVyRXJyb3JcIjtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRva2VuUHJvdmlkZXJFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbiIsImV4cG9ydCBjb25zdCBFWFBJUkVfV0lORE9XX01TID0gNSAqIDYwICogMTAwMDtcbmV4cG9ydCBjb25zdCBSRUZSRVNIX01FU1NBR0UgPSBgVG8gcmVmcmVzaCB0aGlzIFNTTyBzZXNzaW9uIHJ1biAnYXdzIHNzbyBsb2dpbicgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9maWxlLmA7XG4iLCJjb25zdCBzc29PaWRjQ2xpZW50c0hhc2ggPSB7fTtcbmV4cG9ydCBjb25zdCBnZXRTc29PaWRjQ2xpZW50ID0gYXN5bmMgKHNzb1JlZ2lvbikgPT4ge1xuICAgIGNvbnN0IHsgU1NPT0lEQ0NsaWVudCB9ID0gYXdhaXQgaW1wb3J0KFwiQGF3cy1zZGsvY2xpZW50LXNzby1vaWRjXCIpO1xuICAgIGlmIChzc29PaWRjQ2xpZW50c0hhc2hbc3NvUmVnaW9uXSkge1xuICAgICAgICByZXR1cm4gc3NvT2lkY0NsaWVudHNIYXNoW3Nzb1JlZ2lvbl07XG4gICAgfVxuICAgIGNvbnN0IHNzb09pZGNDbGllbnQgPSBuZXcgU1NPT0lEQ0NsaWVudCh7IHJlZ2lvbjogc3NvUmVnaW9uIH0pO1xuICAgIHNzb09pZGNDbGllbnRzSGFzaFtzc29SZWdpb25dID0gc3NvT2lkY0NsaWVudDtcbiAgICByZXR1cm4gc3NvT2lkY0NsaWVudDtcbn07XG4iLCJpbXBvcnQgeyBnZXRTc29PaWRjQ2xpZW50IH0gZnJvbSBcIi4vZ2V0U3NvT2lkY0NsaWVudFwiO1xuZXhwb3J0IGNvbnN0IGdldE5ld1Nzb09pZGNUb2tlbiA9IGFzeW5jIChzc29Ub2tlbiwgc3NvUmVnaW9uKSA9PiB7XG4gICAgY29uc3QgeyBDcmVhdGVUb2tlbkNvbW1hbmQgfSA9IGF3YWl0IGltcG9ydChcIkBhd3Mtc2RrL2NsaWVudC1zc28tb2lkY1wiKTtcbiAgICBjb25zdCBzc29PaWRjQ2xpZW50ID0gYXdhaXQgZ2V0U3NvT2lkY0NsaWVudChzc29SZWdpb24pO1xuICAgIHJldHVybiBzc29PaWRjQ2xpZW50LnNlbmQobmV3IENyZWF0ZVRva2VuQ29tbWFuZCh7XG4gICAgICAgIGNsaWVudElkOiBzc29Ub2tlbi5jbGllbnRJZCxcbiAgICAgICAgY2xpZW50U2VjcmV0OiBzc29Ub2tlbi5jbGllbnRTZWNyZXQsXG4gICAgICAgIHJlZnJlc2hUb2tlbjogc3NvVG9rZW4ucmVmcmVzaFRva2VuLFxuICAgICAgICBncmFudFR5cGU6IFwicmVmcmVzaF90b2tlblwiLFxuICAgIH0pKTtcbn07XG4iLCJpbXBvcnQgeyBUb2tlblByb3ZpZGVyRXJyb3IgfSBmcm9tIFwiQHNtaXRoeS9wcm9wZXJ0eS1wcm92aWRlclwiO1xuaW1wb3J0IHsgUkVGUkVTSF9NRVNTQUdFIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5leHBvcnQgY29uc3QgdmFsaWRhdGVUb2tlbkV4cGlyeSA9ICh0b2tlbikgPT4ge1xuICAgIGlmICh0b2tlbi5leHBpcmF0aW9uICYmIHRva2VuLmV4cGlyYXRpb24uZ2V0VGltZSgpIDwgRGF0ZS5ub3coKSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9rZW5Qcm92aWRlckVycm9yKGBUb2tlbiBpcyBleHBpcmVkLiAke1JFRlJFU0hfTUVTU0FHRX1gLCBmYWxzZSk7XG4gICAgfVxufTtcbiIsImltcG9ydCB7IFRva2VuUHJvdmlkZXJFcnJvciB9IGZyb20gXCJAc21pdGh5L3Byb3BlcnR5LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBSRUZSRVNIX01FU1NBR0UgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVRva2VuS2V5ID0gKGtleSwgdmFsdWUsIGZvclJlZnJlc2ggPSBmYWxzZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRva2VuUHJvdmlkZXJFcnJvcihgVmFsdWUgbm90IHByZXNlbnQgZm9yICcke2tleX0nIGluIFNTTyBUb2tlbiR7Zm9yUmVmcmVzaCA/IFwiLiBDYW5ub3QgcmVmcmVzaFwiIDogXCJcIn0uICR7UkVGUkVTSF9NRVNTQUdFfWAsIGZhbHNlKTtcbiAgICB9XG59O1xuIiwiaW1wb3J0IHsgZ2V0U1NPVG9rZW5GaWxlcGF0aCB9IGZyb20gXCJAc21pdGh5L3NoYXJlZC1pbmktZmlsZS1sb2FkZXJcIjtcbmltcG9ydCB7IHByb21pc2VzIGFzIGZzUHJvbWlzZXMgfSBmcm9tIFwiZnNcIjtcbmNvbnN0IHsgd3JpdGVGaWxlIH0gPSBmc1Byb21pc2VzO1xuZXhwb3J0IGNvbnN0IHdyaXRlU1NPVG9rZW5Ub0ZpbGUgPSAoaWQsIHNzb1Rva2VuKSA9PiB7XG4gICAgY29uc3QgdG9rZW5GaWxlcGF0aCA9IGdldFNTT1Rva2VuRmlsZXBhdGgoaWQpO1xuICAgIGNvbnN0IHRva2VuU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoc3NvVG9rZW4sIG51bGwsIDIpO1xuICAgIHJldHVybiB3cml0ZUZpbGUodG9rZW5GaWxlcGF0aCwgdG9rZW5TdHJpbmcpO1xufTtcbiIsImltcG9ydCB7IFRva2VuUHJvdmlkZXJFcnJvciB9IGZyb20gXCJAc21pdGh5L3Byb3BlcnR5LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBnZXRQcm9maWxlTmFtZSwgZ2V0U1NPVG9rZW5Gcm9tRmlsZSwgbG9hZFNzb1Nlc3Npb25EYXRhLCBwYXJzZUtub3duRmlsZXMsIH0gZnJvbSBcIkBzbWl0aHkvc2hhcmVkLWluaS1maWxlLWxvYWRlclwiO1xuaW1wb3J0IHsgRVhQSVJFX1dJTkRPV19NUywgUkVGUkVTSF9NRVNTQUdFIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBnZXROZXdTc29PaWRjVG9rZW4gfSBmcm9tIFwiLi9nZXROZXdTc29PaWRjVG9rZW5cIjtcbmltcG9ydCB7IHZhbGlkYXRlVG9rZW5FeHBpcnkgfSBmcm9tIFwiLi92YWxpZGF0ZVRva2VuRXhwaXJ5XCI7XG5pbXBvcnQgeyB2YWxpZGF0ZVRva2VuS2V5IH0gZnJvbSBcIi4vdmFsaWRhdGVUb2tlbktleVwiO1xuaW1wb3J0IHsgd3JpdGVTU09Ub2tlblRvRmlsZSB9IGZyb20gXCIuL3dyaXRlU1NPVG9rZW5Ub0ZpbGVcIjtcbmNvbnN0IGxhc3RSZWZyZXNoQXR0ZW1wdFRpbWUgPSBuZXcgRGF0ZSgwKTtcbmV4cG9ydCBjb25zdCBmcm9tU3NvID0gKGluaXQgPSB7fSkgPT4gYXN5bmMgKCkgPT4ge1xuICAgIGluaXQubG9nZ2VyPy5kZWJ1ZyhcIkBhd3Mtc2RrL3Rva2VuLXByb3ZpZGVycyAtIGZyb21Tc29cIik7XG4gICAgY29uc3QgcHJvZmlsZXMgPSBhd2FpdCBwYXJzZUtub3duRmlsZXMoaW5pdCk7XG4gICAgY29uc3QgcHJvZmlsZU5hbWUgPSBnZXRQcm9maWxlTmFtZShpbml0KTtcbiAgICBjb25zdCBwcm9maWxlID0gcHJvZmlsZXNbcHJvZmlsZU5hbWVdO1xuICAgIGlmICghcHJvZmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9rZW5Qcm92aWRlckVycm9yKGBQcm9maWxlICcke3Byb2ZpbGVOYW1lfScgY291bGQgbm90IGJlIGZvdW5kIGluIHNoYXJlZCBjcmVkZW50aWFscyBmaWxlLmAsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXByb2ZpbGVbXCJzc29fc2Vzc2lvblwiXSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9rZW5Qcm92aWRlckVycm9yKGBQcm9maWxlICcke3Byb2ZpbGVOYW1lfScgaXMgbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSAnc3NvX3Nlc3Npb24nLmApO1xuICAgIH1cbiAgICBjb25zdCBzc29TZXNzaW9uTmFtZSA9IHByb2ZpbGVbXCJzc29fc2Vzc2lvblwiXTtcbiAgICBjb25zdCBzc29TZXNzaW9ucyA9IGF3YWl0IGxvYWRTc29TZXNzaW9uRGF0YShpbml0KTtcbiAgICBjb25zdCBzc29TZXNzaW9uID0gc3NvU2Vzc2lvbnNbc3NvU2Vzc2lvbk5hbWVdO1xuICAgIGlmICghc3NvU2Vzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgVG9rZW5Qcm92aWRlckVycm9yKGBTc28gc2Vzc2lvbiAnJHtzc29TZXNzaW9uTmFtZX0nIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiBzaGFyZWQgY3JlZGVudGlhbHMgZmlsZS5gLCBmYWxzZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3NvU2Vzc2lvblJlcXVpcmVkS2V5IG9mIFtcInNzb19zdGFydF91cmxcIiwgXCJzc29fcmVnaW9uXCJdKSB7XG4gICAgICAgIGlmICghc3NvU2Vzc2lvbltzc29TZXNzaW9uUmVxdWlyZWRLZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9rZW5Qcm92aWRlckVycm9yKGBTc28gc2Vzc2lvbiAnJHtzc29TZXNzaW9uTmFtZX0nIGlzIG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgJyR7c3NvU2Vzc2lvblJlcXVpcmVkS2V5fScuYCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNzb1N0YXJ0VXJsID0gc3NvU2Vzc2lvbltcInNzb19zdGFydF91cmxcIl07XG4gICAgY29uc3Qgc3NvUmVnaW9uID0gc3NvU2Vzc2lvbltcInNzb19yZWdpb25cIl07XG4gICAgbGV0IHNzb1Rva2VuO1xuICAgIHRyeSB7XG4gICAgICAgIHNzb1Rva2VuID0gYXdhaXQgZ2V0U1NPVG9rZW5Gcm9tRmlsZShzc29TZXNzaW9uTmFtZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBUb2tlblByb3ZpZGVyRXJyb3IoYFRoZSBTU08gc2Vzc2lvbiB0b2tlbiBhc3NvY2lhdGVkIHdpdGggcHJvZmlsZT0ke3Byb2ZpbGVOYW1lfSB3YXMgbm90IGZvdW5kIG9yIGlzIGludmFsaWQuICR7UkVGUkVTSF9NRVNTQUdFfWAsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFsaWRhdGVUb2tlbktleShcImFjY2Vzc1Rva2VuXCIsIHNzb1Rva2VuLmFjY2Vzc1Rva2VuKTtcbiAgICB2YWxpZGF0ZVRva2VuS2V5KFwiZXhwaXJlc0F0XCIsIHNzb1Rva2VuLmV4cGlyZXNBdCk7XG4gICAgY29uc3QgeyBhY2Nlc3NUb2tlbiwgZXhwaXJlc0F0IH0gPSBzc29Ub2tlbjtcbiAgICBjb25zdCBleGlzdGluZ1Rva2VuID0geyB0b2tlbjogYWNjZXNzVG9rZW4sIGV4cGlyYXRpb246IG5ldyBEYXRlKGV4cGlyZXNBdCkgfTtcbiAgICBpZiAoZXhpc3RpbmdUb2tlbi5leHBpcmF0aW9uLmdldFRpbWUoKSAtIERhdGUubm93KCkgPiBFWFBJUkVfV0lORE9XX01TKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1Rva2VuO1xuICAgIH1cbiAgICBpZiAoRGF0ZS5ub3coKSAtIGxhc3RSZWZyZXNoQXR0ZW1wdFRpbWUuZ2V0VGltZSgpIDwgMzAgKiAxMDAwKSB7XG4gICAgICAgIHZhbGlkYXRlVG9rZW5FeHBpcnkoZXhpc3RpbmdUb2tlbik7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1Rva2VuO1xuICAgIH1cbiAgICB2YWxpZGF0ZVRva2VuS2V5KFwiY2xpZW50SWRcIiwgc3NvVG9rZW4uY2xpZW50SWQsIHRydWUpO1xuICAgIHZhbGlkYXRlVG9rZW5LZXkoXCJjbGllbnRTZWNyZXRcIiwgc3NvVG9rZW4uY2xpZW50U2VjcmV0LCB0cnVlKTtcbiAgICB2YWxpZGF0ZVRva2VuS2V5KFwicmVmcmVzaFRva2VuXCIsIHNzb1Rva2VuLnJlZnJlc2hUb2tlbiwgdHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgbGFzdFJlZnJlc2hBdHRlbXB0VGltZS5zZXRUaW1lKERhdGUubm93KCkpO1xuICAgICAgICBjb25zdCBuZXdTc29PaWRjVG9rZW4gPSBhd2FpdCBnZXROZXdTc29PaWRjVG9rZW4oc3NvVG9rZW4sIHNzb1JlZ2lvbik7XG4gICAgICAgIHZhbGlkYXRlVG9rZW5LZXkoXCJhY2Nlc3NUb2tlblwiLCBuZXdTc29PaWRjVG9rZW4uYWNjZXNzVG9rZW4pO1xuICAgICAgICB2YWxpZGF0ZVRva2VuS2V5KFwiZXhwaXJlc0luXCIsIG5ld1Nzb09pZGNUb2tlbi5leHBpcmVzSW4pO1xuICAgICAgICBjb25zdCBuZXdUb2tlbkV4cGlyYXRpb24gPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgbmV3U3NvT2lkY1Rva2VuLmV4cGlyZXNJbiAqIDEwMDApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgd3JpdGVTU09Ub2tlblRvRmlsZShzc29TZXNzaW9uTmFtZSwge1xuICAgICAgICAgICAgICAgIC4uLnNzb1Rva2VuLFxuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBuZXdTc29PaWRjVG9rZW4uYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0OiBuZXdUb2tlbkV4cGlyYXRpb24udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW46IG5ld1Nzb09pZGNUb2tlbi5yZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46IG5ld1Nzb09pZGNUb2tlbi5hY2Nlc3NUb2tlbixcbiAgICAgICAgICAgIGV4cGlyYXRpb246IG5ld1Rva2VuRXhwaXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHZhbGlkYXRlVG9rZW5FeHBpcnkoZXhpc3RpbmdUb2tlbik7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1Rva2VuO1xuICAgIH1cbn07XG4iLCJpbXBvcnQgeyBmcm9tU3NvIGFzIGdldFNzb1Rva2VuUHJvdmlkZXIgfSBmcm9tIFwiQGF3cy1zZGsvdG9rZW4tcHJvdmlkZXJzXCI7XG5pbXBvcnQgeyBDcmVkZW50aWFsc1Byb3ZpZGVyRXJyb3IgfSBmcm9tIFwiQHNtaXRoeS9wcm9wZXJ0eS1wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0U1NPVG9rZW5Gcm9tRmlsZSB9IGZyb20gXCJAc21pdGh5L3NoYXJlZC1pbmktZmlsZS1sb2FkZXJcIjtcbmNvbnN0IFNIT1VMRF9GQUlMX0NSRURFTlRJQUxfQ0hBSU4gPSBmYWxzZTtcbmV4cG9ydCBjb25zdCByZXNvbHZlU1NPQ3JlZGVudGlhbHMgPSBhc3luYyAoeyBzc29TdGFydFVybCwgc3NvU2Vzc2lvbiwgc3NvQWNjb3VudElkLCBzc29SZWdpb24sIHNzb1JvbGVOYW1lLCBzc29DbGllbnQsIGNsaWVudENvbmZpZywgcHJvZmlsZSwgbG9nZ2VyLCB9KSA9PiB7XG4gICAgbGV0IHRva2VuO1xuICAgIGNvbnN0IHJlZnJlc2hNZXNzYWdlID0gYFRvIHJlZnJlc2ggdGhpcyBTU08gc2Vzc2lvbiBydW4gYXdzIHNzbyBsb2dpbiB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb2ZpbGUuYDtcbiAgICBpZiAoc3NvU2Vzc2lvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgX3Rva2VuID0gYXdhaXQgZ2V0U3NvVG9rZW5Qcm92aWRlcih7IHByb2ZpbGUgfSkoKTtcbiAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBfdG9rZW4udG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShfdG9rZW4uZXhwaXJhdGlvbikudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsc1Byb3ZpZGVyRXJyb3IoZS5tZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgdHJ5TmV4dExpbms6IFNIT1VMRF9GQUlMX0NSRURFTlRJQUxfQ0hBSU4sXG4gICAgICAgICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0b2tlbiA9IGF3YWl0IGdldFNTT1Rva2VuRnJvbUZpbGUoc3NvU3RhcnRVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3JlZGVudGlhbHNQcm92aWRlckVycm9yKGBUaGUgU1NPIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHJvZmlsZSBpcyBpbnZhbGlkLiAke3JlZnJlc2hNZXNzYWdlfWAsIHtcbiAgICAgICAgICAgICAgICB0cnlOZXh0TGluazogU0hPVUxEX0ZBSUxfQ1JFREVOVElBTF9DSEFJTixcbiAgICAgICAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3IERhdGUodG9rZW4uZXhwaXJlc0F0KS5nZXRUaW1lKCkgLSBEYXRlLm5vdygpIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IENyZWRlbnRpYWxzUHJvdmlkZXJFcnJvcihgVGhlIFNTTyBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHByb2ZpbGUgaGFzIGV4cGlyZWQuICR7cmVmcmVzaE1lc3NhZ2V9YCwge1xuICAgICAgICAgICAgdHJ5TmV4dExpbms6IFNIT1VMRF9GQUlMX0NSRURFTlRJQUxfQ0hBSU4sXG4gICAgICAgICAgICBsb2dnZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IGFjY2Vzc1Rva2VuIH0gPSB0b2tlbjtcbiAgICBjb25zdCB7IFNTT0NsaWVudCwgR2V0Um9sZUNyZWRlbnRpYWxzQ29tbWFuZCB9ID0gYXdhaXQgaW1wb3J0KFwiLi9sb2FkU3NvXCIpO1xuICAgIGNvbnN0IHNzbyA9IHNzb0NsaWVudCB8fFxuICAgICAgICBuZXcgU1NPQ2xpZW50KE9iamVjdC5hc3NpZ24oe30sIGNsaWVudENvbmZpZyA/PyB7fSwge1xuICAgICAgICAgICAgcmVnaW9uOiBjbGllbnRDb25maWc/LnJlZ2lvbiA/PyBzc29SZWdpb24sXG4gICAgICAgIH0pKTtcbiAgICBsZXQgc3NvUmVzcDtcbiAgICB0cnkge1xuICAgICAgICBzc29SZXNwID0gYXdhaXQgc3NvLnNlbmQobmV3IEdldFJvbGVDcmVkZW50aWFsc0NvbW1hbmQoe1xuICAgICAgICAgICAgYWNjb3VudElkOiBzc29BY2NvdW50SWQsXG4gICAgICAgICAgICByb2xlTmFtZTogc3NvUm9sZU5hbWUsXG4gICAgICAgICAgICBhY2Nlc3NUb2tlbixcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgQ3JlZGVudGlhbHNQcm92aWRlckVycm9yKGUsIHtcbiAgICAgICAgICAgIHRyeU5leHRMaW5rOiBTSE9VTERfRkFJTF9DUkVERU5USUFMX0NIQUlOLFxuICAgICAgICAgICAgbG9nZ2VyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgeyByb2xlQ3JlZGVudGlhbHM6IHsgYWNjZXNzS2V5SWQsIHNlY3JldEFjY2Vzc0tleSwgc2Vzc2lvblRva2VuLCBleHBpcmF0aW9uLCBjcmVkZW50aWFsU2NvcGUsIGFjY291bnRJZCB9ID0ge30sIH0gPSBzc29SZXNwO1xuICAgIGlmICghYWNjZXNzS2V5SWQgfHwgIXNlY3JldEFjY2Vzc0tleSB8fCAhc2Vzc2lvblRva2VuIHx8ICFleHBpcmF0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsc1Byb3ZpZGVyRXJyb3IoXCJTU08gcmV0dXJucyBhbiBpbnZhbGlkIHRlbXBvcmFyeSBjcmVkZW50aWFsLlwiLCB7XG4gICAgICAgICAgICB0cnlOZXh0TGluazogU0hPVUxEX0ZBSUxfQ1JFREVOVElBTF9DSEFJTixcbiAgICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFjY2Vzc0tleUlkLFxuICAgICAgICBzZWNyZXRBY2Nlc3NLZXksXG4gICAgICAgIHNlc3Npb25Ub2tlbixcbiAgICAgICAgZXhwaXJhdGlvbjogbmV3IERhdGUoZXhwaXJhdGlvbiksXG4gICAgICAgIC4uLihjcmVkZW50aWFsU2NvcGUgJiYgeyBjcmVkZW50aWFsU2NvcGUgfSksXG4gICAgICAgIC4uLihhY2NvdW50SWQgJiYgeyBhY2NvdW50SWQgfSksXG4gICAgfTtcbn07XG4iLCJpbXBvcnQgeyBDcmVkZW50aWFsc1Byb3ZpZGVyRXJyb3IgfSBmcm9tIFwiQHNtaXRoeS9wcm9wZXJ0eS1wcm92aWRlclwiO1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlU3NvUHJvZmlsZSA9IChwcm9maWxlLCBsb2dnZXIpID0+IHtcbiAgICBjb25zdCB7IHNzb19zdGFydF91cmwsIHNzb19hY2NvdW50X2lkLCBzc29fcmVnaW9uLCBzc29fcm9sZV9uYW1lIH0gPSBwcm9maWxlO1xuICAgIGlmICghc3NvX3N0YXJ0X3VybCB8fCAhc3NvX2FjY291bnRfaWQgfHwgIXNzb19yZWdpb24gfHwgIXNzb19yb2xlX25hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IENyZWRlbnRpYWxzUHJvdmlkZXJFcnJvcihgUHJvZmlsZSBpcyBjb25maWd1cmVkIHdpdGggaW52YWxpZCBTU08gY3JlZGVudGlhbHMuIFJlcXVpcmVkIHBhcmFtZXRlcnMgXCJzc29fYWNjb3VudF9pZFwiLCBgICtcbiAgICAgICAgICAgIGBcInNzb19yZWdpb25cIiwgXCJzc29fcm9sZV9uYW1lXCIsIFwic3NvX3N0YXJ0X3VybFwiLiBHb3QgJHtPYmplY3Qua2V5cyhwcm9maWxlKS5qb2luKFwiLCBcIil9XFxuUmVmZXJlbmNlOiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2xpL2xhdGVzdC91c2VyZ3VpZGUvY2xpLWNvbmZpZ3VyZS1zc28uaHRtbGAsIHsgdHJ5TmV4dExpbms6IGZhbHNlLCBsb2dnZXIgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9maWxlO1xufTtcbiIsImltcG9ydCB7IENyZWRlbnRpYWxzUHJvdmlkZXJFcnJvciB9IGZyb20gXCJAc21pdGh5L3Byb3BlcnR5LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBnZXRQcm9maWxlTmFtZSwgbG9hZFNzb1Nlc3Npb25EYXRhLCBwYXJzZUtub3duRmlsZXMgfSBmcm9tIFwiQHNtaXRoeS9zaGFyZWQtaW5pLWZpbGUtbG9hZGVyXCI7XG5pbXBvcnQgeyBpc1Nzb1Byb2ZpbGUgfSBmcm9tIFwiLi9pc1Nzb1Byb2ZpbGVcIjtcbmltcG9ydCB7IHJlc29sdmVTU09DcmVkZW50aWFscyB9IGZyb20gXCIuL3Jlc29sdmVTU09DcmVkZW50aWFsc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVTc29Qcm9maWxlIH0gZnJvbSBcIi4vdmFsaWRhdGVTc29Qcm9maWxlXCI7XG5leHBvcnQgY29uc3QgZnJvbVNTTyA9IChpbml0ID0ge30pID0+IGFzeW5jICgpID0+IHtcbiAgICBpbml0LmxvZ2dlcj8uZGVidWcoXCJAYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVyLXNzbyAtIGZyb21TU09cIik7XG4gICAgY29uc3QgeyBzc29TdGFydFVybCwgc3NvQWNjb3VudElkLCBzc29SZWdpb24sIHNzb1JvbGVOYW1lLCBzc29TZXNzaW9uIH0gPSBpbml0O1xuICAgIGNvbnN0IHsgc3NvQ2xpZW50IH0gPSBpbml0O1xuICAgIGNvbnN0IHByb2ZpbGVOYW1lID0gZ2V0UHJvZmlsZU5hbWUoaW5pdCk7XG4gICAgaWYgKCFzc29TdGFydFVybCAmJiAhc3NvQWNjb3VudElkICYmICFzc29SZWdpb24gJiYgIXNzb1JvbGVOYW1lICYmICFzc29TZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGVzID0gYXdhaXQgcGFyc2VLbm93bkZpbGVzKGluaXQpO1xuICAgICAgICBjb25zdCBwcm9maWxlID0gcHJvZmlsZXNbcHJvZmlsZU5hbWVdO1xuICAgICAgICBpZiAoIXByb2ZpbGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsc1Byb3ZpZGVyRXJyb3IoYFByb2ZpbGUgJHtwcm9maWxlTmFtZX0gd2FzIG5vdCBmb3VuZC5gLCB7IGxvZ2dlcjogaW5pdC5sb2dnZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1Nzb1Byb2ZpbGUocHJvZmlsZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsc1Byb3ZpZGVyRXJyb3IoYFByb2ZpbGUgJHtwcm9maWxlTmFtZX0gaXMgbm90IGNvbmZpZ3VyZWQgd2l0aCBTU08gY3JlZGVudGlhbHMuYCwge1xuICAgICAgICAgICAgICAgIGxvZ2dlcjogaW5pdC5sb2dnZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZmlsZT8uc3NvX3Nlc3Npb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHNzb1Nlc3Npb25zID0gYXdhaXQgbG9hZFNzb1Nlc3Npb25EYXRhKGluaXQpO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNzb1Nlc3Npb25zW3Byb2ZpbGUuc3NvX3Nlc3Npb25dO1xuICAgICAgICAgICAgY29uc3QgY29uZmxpY3RNc2cgPSBgIGNvbmZpZ3VyYXRpb25zIGluIHByb2ZpbGUgJHtwcm9maWxlTmFtZX0gYW5kIHNzby1zZXNzaW9uICR7cHJvZmlsZS5zc29fc2Vzc2lvbn1gO1xuICAgICAgICAgICAgaWYgKHNzb1JlZ2lvbiAmJiBzc29SZWdpb24gIT09IHNlc3Npb24uc3NvX3JlZ2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsc1Byb3ZpZGVyRXJyb3IoYENvbmZsaWN0aW5nIFNTTyByZWdpb25gICsgY29uZmxpY3RNc2csIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5TmV4dExpbms6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IGluaXQubG9nZ2VyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNzb1N0YXJ0VXJsICYmIHNzb1N0YXJ0VXJsICE9PSBzZXNzaW9uLnNzb19zdGFydF91cmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ3JlZGVudGlhbHNQcm92aWRlckVycm9yKGBDb25mbGljdGluZyBTU08gc3RhcnRfdXJsYCArIGNvbmZsaWN0TXNnLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyeU5leHRMaW5rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyOiBpbml0LmxvZ2dlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2ZpbGUuc3NvX3JlZ2lvbiA9IHNlc3Npb24uc3NvX3JlZ2lvbjtcbiAgICAgICAgICAgIHByb2ZpbGUuc3NvX3N0YXJ0X3VybCA9IHNlc3Npb24uc3NvX3N0YXJ0X3VybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNzb19zdGFydF91cmwsIHNzb19hY2NvdW50X2lkLCBzc29fcmVnaW9uLCBzc29fcm9sZV9uYW1lLCBzc29fc2Vzc2lvbiB9ID0gdmFsaWRhdGVTc29Qcm9maWxlKHByb2ZpbGUsIGluaXQubG9nZ2VyKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVTU09DcmVkZW50aWFscyh7XG4gICAgICAgICAgICBzc29TdGFydFVybDogc3NvX3N0YXJ0X3VybCxcbiAgICAgICAgICAgIHNzb1Nlc3Npb246IHNzb19zZXNzaW9uLFxuICAgICAgICAgICAgc3NvQWNjb3VudElkOiBzc29fYWNjb3VudF9pZCxcbiAgICAgICAgICAgIHNzb1JlZ2lvbjogc3NvX3JlZ2lvbixcbiAgICAgICAgICAgIHNzb1JvbGVOYW1lOiBzc29fcm9sZV9uYW1lLFxuICAgICAgICAgICAgc3NvQ2xpZW50OiBzc29DbGllbnQsXG4gICAgICAgICAgICBjbGllbnRDb25maWc6IGluaXQuY2xpZW50Q29uZmlnLFxuICAgICAgICAgICAgcHJvZmlsZTogcHJvZmlsZU5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghc3NvU3RhcnRVcmwgfHwgIXNzb0FjY291bnRJZCB8fCAhc3NvUmVnaW9uIHx8ICFzc29Sb2xlTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgQ3JlZGVudGlhbHNQcm92aWRlckVycm9yKFwiSW5jb21wbGV0ZSBjb25maWd1cmF0aW9uLiBUaGUgZnJvbVNTTygpIGFyZ3VtZW50IGhhc2ggbXVzdCBpbmNsdWRlIFwiICtcbiAgICAgICAgICAgICdcInNzb1N0YXJ0VXJsXCIsIFwic3NvQWNjb3VudElkXCIsIFwic3NvUmVnaW9uXCIsIFwic3NvUm9sZU5hbWVcIicsIHsgdHJ5TmV4dExpbms6IGZhbHNlLCBsb2dnZXI6IGluaXQubG9nZ2VyIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVTU09DcmVkZW50aWFscyh7XG4gICAgICAgICAgICBzc29TdGFydFVybCxcbiAgICAgICAgICAgIHNzb1Nlc3Npb24sXG4gICAgICAgICAgICBzc29BY2NvdW50SWQsXG4gICAgICAgICAgICBzc29SZWdpb24sXG4gICAgICAgICAgICBzc29Sb2xlTmFtZSxcbiAgICAgICAgICAgIHNzb0NsaWVudCxcbiAgICAgICAgICAgIGNsaWVudENvbmZpZzogaW5pdC5jbGllbnRDb25maWcsXG4gICAgICAgICAgICBwcm9maWxlOiBwcm9maWxlTmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbiIsImV4cG9ydCAqIGZyb20gXCIuL2Zyb21TU09cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2lzU3NvUHJvZmlsZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHlwZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3ZhbGlkYXRlU3NvUHJvZmlsZVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9795\n')}};